## 十、全局搜索实现

### 10.1 搜索功能概述

Linear 全局搜索支持：
- 全文搜索（标题、描述、评论）
- 类型过滤（Issue、Project、Document、User）
- 属性过滤（状态、优先级、负责人等）
- 搜索操作符（前缀语法）
- 相关性排序

### 10.2 搜索操作符语法

| 前缀 | 说明 | 示例 |
|------|------|------|
| `i:` | 搜索 Issue | `i:login bug` |
| `p:` | 搜索 Project | `p:mobile app` |
| `u:` | 搜索 User | `u:john` |
| `t:` | 搜索 Team | `t:engineering` |
| `d:` | 搜索 Document | `d:api spec` |
| `l:` | 按标签过滤 | `l:bug l:urgent` |
| `s:` | 按状态过滤 | `s:"in progress"` |
| `a:` | 按负责人过滤 | `a:me` |
| `pr:` | 按优先级过滤 | `pr:high` |
| `c:` | 按 Cycle 过滤 | `c:current` |
| `"..."` | 精确匹配 | `"exact phrase"` |

**组合示例**：
```
i:auth l:bug s:"in progress" a:me
```
搜索负责人是我、状态是进行中、有 bug 标签的包含 auth 关键字的 Issue

### 10.3 搜索解析器

```typescript
// 搜索查询解析
interface SearchQuery {
  text: string;           // 全文搜索关键词
  types: string[];        // 资源类型
  filters: SearchFilter[]; // 过滤条件
}

interface SearchFilter {
  field: string;    // 字段名
  operator: string; // 操作符：eq, in, contains, etc.
  value: any;       // 值
}

class SearchParser {
  parse(queryString: string): SearchQuery {
    const result: SearchQuery = {
      text: '',
      types: [],
      filters: []
    };

    // 正则匹配操作符
    const operatorRegex = /(\w+):("(?:[^"\\]|\\.)*"|[\w-]+)/g;
    let match;
    let remainingText = queryString;

    while ((match = operatorRegex.exec(queryString)) !== null) {
      const [fullMatch, operator, value] = match;
      remainingText = remainingText.replace(fullMatch, '').trim();

      // 解析值（去除引号）
      const cleanValue = value.replace(/^"|"$/g, '');

      switch (operator) {
        case 'i':
          result.types.push('issue');
          break;
        case 'p':
          result.types.push('project');
          break;
        case 'u':
          result.types.push('user');
          break;
        case 'l':
          result.filters.push({ field: 'labels', operator: 'contains', value: cleanValue });
          break;
        case 's':
          result.filters.push({ field: 'status', operator: 'eq', value: cleanValue });
          break;
        case 'a':
          result.filters.push({
            field: 'assignee_id',
            operator: 'eq',
            value: cleanValue === 'me' ? 'current_user' : cleanValue
          });
          break;
        case 'pr':
          result.filters.push({ field: 'priority', operator: 'eq', value: cleanValue });
          break;
        case 'c':
          result.filters.push({ field: 'cycle_id', operator: 'eq', value: cleanValue });
          break;
      }
    }

    result.text = remainingText;
    return result;
  }
}
```

### 10.4 PostgreSQL 全文搜索实现

```sql
-- 创建全文搜索索引
CREATE INDEX idx_issue_search ON issue
USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')));

-- 搜索函数
CREATE OR REPLACE FUNCTION search_issues(
  search_query TEXT,
  team_ids UUID[] DEFAULT NULL,
  status_ids UUID[] DEFAULT NULL,
  assignee_id UUID DEFAULT NULL,
  priority INTEGER DEFAULT NULL,
  limit_count INTEGER DEFAULT 50
) RETURNS TABLE (
  id UUID,
  title TEXT,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id,
    i.title,
    ts_rank(
      to_tsvector('english', i.title || ' ' || COALESCE(i.description, '')),
      plainto_tsquery('english', search_query)
    ) AS rank
  FROM issue i
  WHERE
    -- 全文搜索条件
    to_tsvector('english', i.title || ' ' || COALESCE(i.description, ''))
      @@ plainto_tsquery('english', search_query)
    -- 可选过滤条件
    AND (team_ids IS NULL OR i.team_id = ANY(team_ids))
    AND (status_ids IS NULL OR i.status_id = ANY(status_ids))
    AND (assignee_id IS NULL OR i.assignee_id = assignee_id)
    AND (priority IS NULL OR i.priority = priority)
  ORDER BY
    -- 相关性排序：状态权重 + 时间权重 + 文本匹配
    CASE
      WHEN i.status->>'type' = 'started' THEN 2.0
      WHEN i.status->>'type' = 'unstarted' THEN 1.5
      ELSE 1.0
    END * rank DESC,
    i.updated_at DESC
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;
```

### 10.5 相关性排序算法

```go
// 搜索结果排序
type SearchResult struct {
    Entity    interface{}
    Score     float64
    Highlights map[string]string
}

func CalculateRelevanceScore(issue *Issue, queryString string, baseScore float64) float64 {
    score := baseScore

    // 1. 状态权重
    switch issue.Status.Type {
    case "started":
        score *= 2.0 // 进行中的 Issue 优先
    case "unstarted":
        score *= 1.5
    }

    // 2. 时间权重（最近更新的优先）
    daysSinceUpdate := time.Since(issue.UpdatedAt).Hours() / 24
    timeWeight := 1.0 / (1.0 + daysSinceUpdate/7.0) // 每周衰减
    score *= (1.0 + timeWeight)

    // 3. 优先级权重
    priorityWeights := map[int]float64{
        1: 1.5, // Urgent
        2: 1.3, // High
        3: 1.1, // Medium
        4: 1.0, // Low
        0: 1.0, // None
    }
    score *= priorityWeights[issue.Priority]

    // 4. 标题匹配加成
    if strings.Contains(strings.ToLower(issue.Title), strings.ToLower(queryString)) {
        score *= 1.5
    }

    return score
}
```

### 10.6 搜索限制与分页

- **最大结果数**：500 条（未过滤）/ 1000 条（有类型过滤）
- **分页**：使用游标分页，每页默认 50 条
- **高亮**：搜索结果中高亮匹配的文本片段

---

### 10.7 搜索设计分析

#### 前缀语法的设计价值

前缀语法（如 `i:auth l:bug s:"in progress" a:me`）是 Linear 搜索的亮点设计：

- **降低学习成本**：直觉化前缀，无需学习复杂的查询语言
- **混合搜索**：关键词全文搜索 + 属性精确过滤在同一查询中混合使用
- **渐进增强**：用户可以从简单关键词搜索开始，逐步使用前缀语法提高搜索精度

#### 相关性排序策略

多维度评分保证搜索结果的实用性：

| 权重维度 | 策略 | 原因 |
|---------|------|------|
| 状态权重 | `started` ×2.0 / `unstarted` ×1.5 | 进行中的 Issue 更紧迫 |
| 时间衰减 | 每周衰减 | 最近更新的更相关 |
| 优先级权重 | Urgent ×1.5 / High ×1.3 | 高优先级更需要关注 |
| 标题匹配 | 标题包含关键词 ×1.5 | 标题匹配比描述匹配更精准 |

#### 技术选型考量

- **PostgreSQL 全文搜索**足以覆盖绝大多数场景，无需引入额外搜索引擎
- GIN 索引 + `ts_rank` 排序是主要实现手段
- 后期数据量增长后，可引入 Elasticsearch/MeiliSearch 作为增强

---
